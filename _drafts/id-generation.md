---
layout: post
title:  Distributed ID generation with Redis and Lua
date:   2015-03-13 19:32:00
excerpt: How to generate globally unique IDs in a distributed fashion with Redis and Lua.
image: /assets/images/id-generation.jpg
thumbnail: /assets/images/id-generation-thumbnail.jpg
categories: engineering
author: Nathan Kleyn
---

**TL;DR:** We are open-sourcing our distributed _k_-ordered ID generation project called "Icicle", which generates IDs using Lua scripting within distributed Redis hosts. You can [find more information in the GitHub repository](https://github.com/intenthq/icicle)!

At Intent HQ, we generate a lot of data. Part of the task of capturing this data is the package it up into a common format and store it in a way it can be retrieved. Commonly, labelling this data in a way that facilitates retrival is a task handled by your database. However, in a big-data environment, we need a way to label these pieces of data with an ID in a distributed and scalable way independent of a database.

Over the course of this article, we'll walk you through how we arrived at a solution for generating IDs in a distributed fashion using the Redis instances we already had deployed and in a format that allows _k_-ordering. We'll share with you the code for doing this so you can use this ID generation in your own projects!

## What is an ID?

An ID can be many things, but surely its most important definition is that of "uniqueness". Of all the properties, this is the only one that truly matters. If you label a piece of data with an ID, you want to be sure you don't later have abiguities when looking up that data again by the ID you had.

IDs may have some other useful properties, however:

* _Ordered:_ They may be ordered to allow comparison of items stamped with IDs.

* _Meaningful:_ They may embed certain information about the point at which the ID was generated, for example the time (however inexact).

* _Distributed:_ They may be generated by a machine without consulating any other machine (ie. they must be truly distributed).

* _Compact:_ They may be represented in a specific format for space or performance reasons. Normally, you'd want to represent this in as compact a format as possible but you often trade-off longevity to do this ([32-bit UNIX timestamps are a great example of this](https://en.wikipedia.org/wiki/Year_2038_problem)).

These all sound like useful properties to have in an ID, but existing methods don't really work to preserve these properties in a distributed environment. Traditionally, in software, we have generated IDs using methods that do not scale. Either we let an application like a database generate IDs for us, in which case we (generally) have a single point-of-failure, or we use standards like the UUID which [do not guarantee uniqueness in a distributed environment without significant efforts at coordination](http://en.wikipedia.org/wiki/Universally_unique_identifier#Random_UUID_probability_of_duplicates).

As a turns out, primarily, the reasons for doing this are deeply rooted in our inability to keep time across a distributed environment.

## Time is hard

Keeping time is actually a really hard problem to solve. At the core of the issue is the fact that computers suffer from "clock drift", where the clock is constantly skewing forwards or backwards away from the actual time. Perhaps even worse, [every computer skews at a different rate](https://en.wikipedia.org/wiki/Clock_skew).

Thus, the concept of a "time oracle" is born. Time oracles dedicated servers normally equipped with an atomic clock or GPS device whose sole purpose is for keeping time in as precice a manner as possible. Time oracle servers are used frequently in environments where super accurate time is important (such as trading platforms and financial applications), but they are prohibitively expensive and not a viable solution for those unable to manage their own physical server.

NTP was specifically written to ameliorate this problem for those who cannot access a dedicated time oracle. The idea is basically that large organisations donate access to their time oracle servers by adding them to a global pool of NTP servers which can use to adjust their clock against. This is, unfortunately, not without its problems. Its an error prone process, as it involves network hops and jitter, and is thus succeptable to all kinds of inaccuracies that the underlying algorithms do their best to abate but cannot avoid.

Thus, you're left with one immutable fact: time is never constant in a distributed environment. You can can never solely rely on time for ordering or identification, as we can simply not guarantee these properties over multiple hosts without a dedicated time oracle.

## Ordering

The first property of IDs that breaks down in a distributed environment is that of ordering. In tranditional SQL databases, we still use things like auto incrementing primary keys, despite knowing it has [serious limitations in a replicated environment](http://scale-out-blog.blogspot.co.uk/2012/04/if-you-must-deploy-multi-master.html). Horrifically, some people even use global coordination techniques like locking to make sure IDs like this don't get duplicated or out-of-order. This is a recipe for scalability and performance woes! Using time for ordering would be convenient because we don't need to coordinate on this value, but as we know time isn't a precise thing in a distributed environment, we know we can't use it on its own.

Chances are, in most applications you actually care more about uniqueness than ordering. What if we were to relax our requirements for ordering so that we could use time as a backing for our ID in a way that could be distributed?

This is where _k_-ordering comes in. The term "_k_-ordered" is can be applied to anything which can be "loosely ordered". That is, if I gave you the following numbers:

> 1, 5, 100, 102, 2, 101

A _k_-ordered copy of these numbers might look something like this:

> 1, 5, 2, 100, 102, 101

They are mostly, but not exactly, in order. Notice that really, all we're doing here is loosly ordering on the first part of the number: numbers less than 100 before numbers greater than 100. If we apply this to an ID, we may be able to sort on just a small portion of the ID to sort them. Perhaps the first portion of our ID could be the time, so as to allow ordering, and we could put put some stuff at the end that gurantees uniqueness?

## The structure of an ID

We have the seeds for an ID: we know it will have time in it, we know it needs to have something that will make it unique across many nodes, and we'd preferably like it to be as small as possible for performance reasons. Without pretense, I give you the structure of our IDs:

> ABBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBBCCCCCCCCCCDDDDDDDDDDDD

Where:

* A is the reserved signed bit (which we chose not to use because some platforms make it difficult to get at).

* B is the timestamp in milliseconds since a custom epoch, 41 bits in total.

* C is the logical shard ID, 10 bits in total.

* D is the sequence, 12 bits in total.

We have represented the time as a 41-bit integer by creating a custom epoch: this simply involves picking an arbitrary point in time, calling it "0", and starting to count the milliseconds from there.

We have decided to generate IDs using Redis, but Redis is not distributed by default, so we "assign" each node an ID, called the "logical shard ID". This is simply a number between 0 and 1023 to distinguish one node from another. This ensures that if two nodes are asked for an ID during the same millisecond, they'll return different IDs.

What if a single node is asked for an ID again in the same millisecond though? Well, we have the "sequence number" to take care of that. This is simply a 12 bit number that starts at 0 and increments up to 4095 before looping back to 0 and starting again. This effectively means we can generate a maximum of 4096 IDs, per millisecond, per node. We have a maximum of 1024 nodes, we we can generate a theoretical maximum of 4,194,304 IDs in a single millisecond without duplicates.

With all this together, once a list of IDs is sorted, they'll be grouped together by time and sorted by the (relatively) meaningless shard ID and sequence number after that. That is, they'll be _k_-sorted by time.

## Redis and Lua

The final piece of the puzzle is in how we use Redis to do this.

Redis lacks the ability to run commands in a transaction based on logic, so we chose to implement the logic in Lua and pass it to Redis using its scripting functionality. At the time of coding, the bitops library provided by Redis didn't allow us to do what we needed to do to compose the 64-bit ID in pure Lua, so we currently call to Redis with the Lua script to get the components which make up the ID (time, logical shard ID, sequence) and bit-shift them all together in the client-library (which is currently written in Java).

One interesting aspect of Redis is that it does not actually support any form of distributed mode (that will change in version 3 when Redis cluster is released). As a result, we implement a naÃ¯ve round-robin algorithm to cycle between a pool of Redis servers. This allows us to have full redundancy, and a relatively evenly distributed load across the servers.

## Open-source goodness

> FIXME: Actual URL to Lua script needs to be added when repository is pushed.

Now you know the theory and limitations behind generating distributed IDs, [we've open-sourced our implementation of these ideas on GitHub as "Icicle"](https://github.com/intenthq/icicle). The reference implementation is in Java, but really you could reimplment this easily in any language (remember, the primary part of it is [the Lua script that gets passed to Redis](FIXME), which is already implemented for you!)

Contributions to the source-code are welcome via GitHub pull requests!

**p.s.:** The name was inspired by a (sadly) now defunct project from Twitter called "Snowflake", from which we drew much inspiration. There's also a deriviative project written in Erlang called ["Flake"](http://www.boundary.com/blog/2012/01/flake-a-decentralized-k-ordered-unique-id-generator-in-erlang/) that does 128-bit IDs, you may find it interesting!

_[Image of fingerprint](http://en.wikipedia.org/wiki/Fingerprint#/media/File:Fingerprint_detail_on_male_finger.jpg) by [Frettie](http://commons.wikimedia.org/wiki/User:Frettie) is licensed under [CC BY 3.0](http://creativecommons.org/licenses/by/3.0/)_
